# Otchet
: Список List-Python

Список (list) – это структура данных для хранения объектов различных типов. Если вы использовали другие языки программирования, то вам должно быть знакомо понятие массива. Так вот, список очень похож на массив, только, как было уже сказано выше, в нем можно хранить объекты различных типов. Размер списка не статичен, его можно изменять. Список по своей природе является изменяемым типом данных. Переменная, определяемая как список, содержит ссылку на структуру в памяти, которая в свою очередь хранит ссылки на какие-либо другие объекты или структуры.

: Хронение списков в пямяти

Как уже было сказано выше, список является изменяемым типом данных. При его создании в памяти резервируется область, которую можно условно назвать некоторым “контейнером”, в котором хранятся ссылки на другие элементы данных в памяти. В отличии от таких типов данных как число или строка, содержимое “контейнера” списка можно менять. Для того, чтобы лучше визуально представлять себе этот процесс взгляните на картинку ниже. Изначально был создан список содержащий ссылки на объекты 1 и 2, после операции a[1] = 3, вторая ссылка в списке стала указывать на объект 3.

: Создание, изменение, удаление списков и работа с его элементами

Создать список можно одним из следующих способов.

1.>>> a = [] 
2.>>> type(a) 
3.<class 'list'> 
4.>>> b = list() 
5.>>> type(b) 
6.<class 'list'>

Также можно создать список с заранее заданным набором данных.

1.>>> a = [1, 2, 3] 
2.>>> type(a) 
3.<class 'list'>

Если у вас уже есть список и вы хотите создать его копию, то можно воспользоваться следующим способом:

1.>>> a = [1, 3, 5, 7] 
2.>>> b = a[:] 
3.>>> print(a) 
4.[1, 3, 5, 7] 
5.>>> print(b) 
6.[1, 3, 5, 7]

или сделать это так:

1.>>> a = [1, 3, 5, 7] 
2.>>> b = list(a) 
3.>>> print(a) 
4.[1, 3, 5, 7] 
5.>>> print(b) 
6.[1, 3, 5, 7]

В случае, если вы выполните простое присвоение списков друг другу, то переменной b будет присвоена ссылка на тот же элемент данных в памяти, на который ссылается a, а не копия списка а. Т.е. если вы будете изменять список a, то и b тоже будет меняться.

1.>>> a = [1, 3, 5, 7] 
2.>>> b = a 
3.>>> print(a) 
4.[1, 3, 5, 7] 
5.>>> print(b) 
6.[1, 3, 5, 7] 
7.>>> a[1] = 10 
8.>>> print(a) 
9.[1, 10, 5, 7] 
10.>>> print(b) 
11.[1, 10, 5, 7]

Добавление элемента в список осуществляется с помощью метода append().

1.>>> a = [] 
2.>>> a.append(3) 
3.>>> a.append("hello") 
4.>>> print(a) 
5.[3, 'hello']

Для удаления элемента из списка, в случае, если вы знаете его значение, используйте метод remove(x), при этом будет удалена первая ссылка на данный элемент.

1.>>> b = [2, 3, 5] 
2.>>> print(b) 
3.[2, 3, 5] 
4.>>> b.remove(3) 
5.>>> print(b) 
6.[2, 5]

Если необходимо удалить элемент по его индексу, воспользуйтесь командой del имя_списка[индекс].

1.>>> c = [3, 5, 1, 9, 6] 
2.>>> print(c) 
3.[3, 5, 1, 9, 6] 
4.>>> del c[2] 
5.>>> print(c) 
6.[3, 5, 9, 6]

Изменить значение элемента списка, зная его индекс, можно напрямую к нему обратившись.

1.>>> d = [2, 4, 9] 
2.>>> print(d) 
3.[2, 4, 9] 
4.>>> d[1] = 17 
5.>>> print(d) 
6.[2, 17, 9]

Очистить список можно просто заново его проинициализировав, так как будто вы его вновь создаете. Для получения доступа к элементу списка укажите индекс этого элемента в квадратных скобках.

1.>>> a = [3, 5, 7, 10, 3, 2, 6, 0] 
2.>>> a[2] 
3.7

Можно использовать отрицательные индексы, в таком случае счет будет идти с конца, например для доступа к последнему элементу списка можно использовать вот такую команду:

1.>>> a[-1] 
2.0

Для получения из списка некоторого подсписка в определенном диапазоне индексов, укажите начальный и конечный индекс в квадратных скобках, разделив их двоеточием.

1.>>> a[1:4] 
2.[5, 7, 10]

: Методы списков

list.append(x)

Добавляет элемент в конец списка. Ту же операцию можно сделать так a[len(a):] = [x].

1.>>> a = [1, 2] 
2.>>> a.append(3) 
3.>>> print(a) 
4.[1, 2, 3]

list.extend(L)

Расширяет существующий список за счет добавления всех элементов из списка L. Эквивалентно команде a[len(a):] = L.

1.>>> a = [1, 2] 
2.>>> b = [3, 4] 
3.>>> a.extend(b) 
4.>>> print(a) 
5.[1, 2, 3, 4]

list.insert(i, x)

Вставить элемент x в позицию i.  Первый аргумент – индекс элемента после которого будет вставлен элемент x.

1.>>> a = [1, 2] 
2.>>> a.insert(0, 5) 
3.>>> print(a) 
4.[5, 1, 2] 
5.>>> a.insert(len(a), 9) 
6.>>> print(a) 
7.[5, 1, 2, 9]

list.remove(x)

Удаляет первое вхождение элемента x из списка.

1.>>> a = [1, 2, 3] 
2.>>> a.remove(1) 
3.>>> print(a) 
4.[2, 3]

list.pop([i])

Удаляет элемент из позиции i и возвращает его. Если использовать метод без аргумента, то будет удален последний элемент из списка.

1.>>> a = [1, 2, 3, 4, 5] 
2.>>> print(a.pop(2)) 
3.3 
4.>>> print(a.pop()) 
5.5 
6.>>> print(a) 
7.[1, 2, 4]

list.clear()

Удаляет все элементы из списка. Эквивалентно del a[:].

1.>>> a = [1, 2, 3, 4, 5] 
2.>>> print(a) 
3.[1, 2, 3, 4, 5] 
4.>>> a.clear() 
5.>>> print(a) 
6.[]

list.index(x[, start[, end]])

Возвращает индекс элемента.

1.>>> a = [1, 2, 3, 4, 5] 
2.>>> a.index(4) 
3.3

list.count(x)

Возвращает количество вхождений элемента x в список.

1.>>> a=[1, 2, 2, 3, 3] 
2.>>> print(a.count(2)) 
3.2

list.sort(key=None, reverse=False)

Сортирует элементы в списке по возрастанию. Для сортировки в обратном порядке используйте флаг reverse=True. Дополнительные возможности открывает параметр key, за более подробной информацией обратитесь к документации.

1.>>> a = [1, 4, 2, 8, 1] 
2.>>> a.sort() 
3.>>> print(a) 
4.[1, 1, 2, 4, 8]

list.reverse()

Изменяет порядок расположения элементов в списке на обратный.

1.>>> a = [1, 3, 5, 7] 
2.>>> a.reverse() 
3.>>> print(a) 
4.[7, 5, 3, 1]

list.copy()

Возвращает копию списка. Эквивалентно a[:].

1.>>> a = [1, 7, 9] 
2.>>> b = a.copy() 
3.>>> print(a) 
4.[1, 7, 9] 
5.>>> print(b) 
6.[1, 7, 9] 
7.>>> b[0] = 8 
8.>>> print(a) 
9.[1, 7, 9] 
10.>>> print(b) 
11.[8, 7, 9]

List Comprehensions:

List Comprehensions чаще всего на русский язык переводят как  абстракция списков или списковое включение, является частью синтаксиса языка, которая предоставляет простой способ построения списков. Проще всего работу list comprehensions показать на примере. Допустим вам необходимо создать список целых чисел от 0 до n, где n предварительно задается. Классический способ решения данной задачи выглядел бы так:

1.>>> n = int(input())
2.7
3.>>> a=[]
4.>>> for i in range(n):
5.        a.append(i)
6.>>> print(a)
7.[0, 1, 2, 3, 4, 5, 6]

Использование list comprehensions позволяет сделать это значительно проще:

1.>>> n = int(input())
2.7
3.>>> a = [i for i in range(n)]
4.>>> print(a)
5.[0, 1, 2, 3, 4, 5, 6]

или вообще вот так, в случае если вам не нужно больше использовать n:

1.>>> a = [i for i in range(int(input()))]
2.7
3.>>> print(a)
4.[0, 1, 2, 3, 4, 5, 6]

List Comprehensions как обработчик списков:

В языке Python есть две очень мощные функции для работы с коллекциями: map и filter. Они позволяют использовать функциональный стиль программирования, не прибегая к помощи циклов, для работы с такими типами как list, tuple, set, dict и т.п. Списковое включение позволяет обойтись без этих функций. Приведем несколько примеров для того, чтобы понять о чем идет речь.

Пример с заменой функции map.

Пусть у нас есть список и нужно получить на базе него новый, который содержит элементы первого, возведенные в квадрат. Решим эту задачу с использованием циклов:

1.>>> a = [1, 2, 3, 4, 5, 6, 7]
2.>>> b = []
3.>>> for i in a:
4.        b.append(i**2)
5.>>> print('a = {}\nb = {}'.format(a, b))
6.a = [1, 2, 3, 4, 5, 6, 7]
7.b = [1, 4, 9, 16, 25, 36, 49]

Та же задача, решенная с использованием map, будет выглядеть так:

1.>>> a = [1, 2, 3, 4, 5, 6, 7]
2.>>> b = list(map(lambda x: x**2, a))
3.>>> print('a = {}\nb = {}'.format(a, b))
4.a = [1, 2, 3, 4, 5, 6, 7]
5.b = [1, 4, 9, 16, 25, 36, 49]

В данном случае применена lambda-функция, о том, что это такое и как ее использовать можете прочитать здесь.

Через списковое включение эта задача будет решена так:

1.>>> a = [1, 2, 3, 4, 5, 6, 7]
2.>>> b = [i**2 for i in a]
3.>>> print('a = {}\nb = {}'.format(a, b))
4.a = [1, 2, 3, 4, 5, 6, 7]
5.b = [1, 4, 9, 16, 25, 36, 49]

Пример с заменой функции filter.

Построим на базе существующего списка новый, состоящий только из четных чисел:

1.>>> a = [1, 2, 3, 4, 5, 6, 7]
2.>>> b = []
3.>>> for i in a:
4.        if i%2 == 0:
5.            b.append(i)
6.>>> print('a = {}\nb = {}'.format(a, b))
7.a = [1, 2, 3, 4, 5, 6, 7]
8.b = [2, 4, 6]

Решим эту задачу с использованием filter:

1.>>> a = [1, 2, 3, 4, 5, 6, 7]
2.>>> b = list(filter(lambda x: x % 2 == 0, a))
3.>>> print('a = {}\nb = {}'.format(a, b))
4.a = [1, 2, 3, 4, 5, 6, 7]
5.b = [2, 4, 6]

Решение через списковое включение:

1.>>> a = [1, 2, 3, 4, 5, 6, 7]
2.>>> b = [i for i in a if i % 2 == 0]
3.>>> print('a = {}\nb = {}'.format(a, b))
4.a = [1, 2, 3, 4, 5, 6, 7]
5.b = [2, 4, 6]

:Слайсы / Срезы

Слайсы (срезы) являются очень мощной составляющей Python, которая позволяет быстро и лаконично решать задачи выборки элементов из списка. Выше уже был пример использования слайсов, здесь разберем более подробно работу с ними. Создадим список для экспериментов:

1.>>> a = [i for i in range(10)]

Слайс задается тройкой чисел, разделенных запятой: start:stop:step. Start – позиция с которой нужно начать выборку, stop – конечная позиция, step – шаг. При этом необходимо помнить, что выборка не включает элемент определяемый stop.

Рассмотрим примеры:

1.>>> # Получить копию списка
2.>>> a[:]
3.[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
4.>>> # Получить первые пять элементов списка
5.>>> a[0:5]
6.[0, 1, 2, 3, 4]
7.>>> # Получить элементы с 3-го по 7-ой
8.>>> a[2:7]
9.[2, 3, 4, 5, 6]
10.>>> # Взять из списка элементы с шагом 2
11.>>> a[::2]
12.[0, 2, 4, 6, 8]
13.>>> # Взять из списка элементы со 2-го по 8-ой с шагом 2
14.>>> a[1:8:2]
15.[1, 3, 5, 7]

Слайсы можно сконструировать заранее, а потом уже использовать по мере необходимости. Это возможно сделать, в виду того, что слайс – это объект класса slice. Ниже приведен пример, демонстрирующий эту функциональность:

1.>>> s = slice(0, 5, 1)
2.>>> a[s]
3.[0, 1, 2, 3, 4]
4.>>> s = slice(1, 8, 2)
5.>>> a[s]
6.[1, 3, 5, 7]

Типо “List Comprehensions”… в генераторном режиме
Есть ещё одни способ создания списков, который похож на списковое включение, но результатом работы является не объект класса list, а генератор. Подробно про генераторы написано в “Уроке 15. Итераторы и генераторы“.

Предварительно импортируем модуль sys, он нам понадобится:

1.>>> import sys

Создадим список, используя списковое включение :

1.>>> a = [i for i in range(10)]

проверим тип переменной a:

1.>>> type(a)
2.<class 'list'>

и посмотрим сколько она занимает памяти в байтах:

1.>>> sys.getsizeof(a)
2.192

Для создания объекта-генератора, используется синтаксис такой же как и для спискового включения, только вместо квадратных скобок используются круглые:

1.>>> b = (i for i in range(10))
2.>>> type(b)
3.<class 'generator'>
4.>>> sys.getsizeof(b)
5.120

Обратите внимание, что тип этого объекта ‘generator’, и в памяти он занимает места меньше, чем список, это объясняется тем, что в первом случае в памяти хранится весь набор чисел от 0 до 9, а во втором функция, которая будет нам генерировать числа от 0 до 9. Для наших примеров разница в размере не существенна, рассмотрим вариант с 10000 элементами:

1.>>> c = [i for i in range(10000)]
2.>>> sys.getsizeof(c)
3.87624
4.>>> d = (i for i in range(10000))
5.>>> sys.getsizeof(d)
6.120

Сейчас уже разница существенна, как вы уже поняли, размер генератора в данном случае не будет зависеть от количества чисел, которые он должен создать.

Если вы решаете задачу обхода списка, то  принципиальной разницы между списком и генератором не будет:

1.>>> for val in a:
2.        print(val, end=' ')
3.0 1 2 3 4 5 6 7 8 9 
4.>>> for val in b:
5.        print(val, end=' ')
6.0 1 2 3 4 5 6 7 8 9

Но с генератором нельзя работать также как и со списком: 
Нельзя обратиться к элементу по индексу и т.п.




























Объяснение алгоритмов сортировки с примерами на Python:

В этой статье будут рассмотрены популярные алгоритмы, принципы их работы и реализация на Python. А ещё сравним, как быстро они сортируют элементы в списке.

В качестве общего примера возьмём сортировку чисел в порядке возрастания. Но эти методы можно легко адаптировать под ваши потребности.

Пузырьковая сортировка:

Этот простой алгоритм выполняет итерации по списку, сравнивая элементы попарно и меняя их местами, пока более крупные элементы не «всплывут» в начало списка, а более мелкие не останутся на «дне».

Алгоритм:

Сначала сравниваются первые два элемента списка. Если первый элемент больше, они меняются местами. Если они уже в нужном порядке, оставляем их как есть. Затем переходим к следующей паре элементов, сравниваем их значения и меняем местами при необходимости. Этот процесс продолжается до последней пары элементов в списке.

При достижении конца списка процесс повторяется заново для каждого элемента. Это крайне неэффективно, если в массиве нужно сделать, например, только один обмен. Алгоритм повторяется n² раз, даже если список уже отсортирован.Для оптимизации алгоритма нужно знать, когда его остановить, то есть когда список отсортирован.

Чтобы остановить алгоритм по окончании сортировки, нужно ввести переменную-флаг. Когда значения меняются местами, устанавливаем флаг в значение True, чтобы повторить процесс сортировки. Если перестановок не произошло, флаг остаётся False и алгоритм останавливается.

:Реализация


1.def bubble_sort(nums):  
2.    # Устанавливаем swapped в True, чтобы цикл запустился хотя бы один раз
3.    swapped = True
4.    while swapped:
5.        swapped = False
6.        for i in range(len(nums) - 1):
7.            if nums[i] > nums[i + 1]:
8.                # Меняем элементы
9.                nums[i], nums[i + 1] = nums[i + 1], nums[i]
10.                # Устанавливаем swapped в True для следующей итерации
11.                swapped = True

12.# Проверяем, что оно работает

13.random_list_of_nums = [5, 2, 1, 8, 4]  
14.bubble_sort(random_list_of_nums)  
15.print(random_list_of_nums)

Алгоритм работает в цикле while и прерывается, когда элементы ни разу не меняются местами. Вначале присваиваем swapped значение True, чтобы алгоритм запустился хотя бы один раз.

Время сортировки:

Если взять самый худший случай (изначально список отсортирован по убыванию), затраты времени будут равны O(n²), где n — количество элементов списка.

Сортировка выборкой:

Этот алгоритм сегментирует список на две части: отсортированную и неотсортированную. Наименьший элемент удаляется из второго списка и добавляется в первый.

Алгоритм:

На практике не нужно создавать новый список для отсортированных элементов. В качестве него используется крайняя левая часть списка. Находится наименьший элемент и меняется с первым местами.

Теперь, когда нам известно, что первый элемент списка отсортирован, находим наименьший элемент из оставшихся и меняем местами со вторым. Повторяем это до тех пор, пока не останется последний элемент в списке.

Реализация:

1.def selection_sort(nums):  
2.    # Значение i соответствует кол-ву отсортированных значений
3.    for i in range(len(nums)):
4.        # Исходно считаем наименьшим первый элемент
5.        lowest_value_index = i
6.        # Этот цикл перебирает несортированные элементы
7.        for j in range(i + 1, len(nums)):
8.            if nums[j] < nums[lowest_value_index]:
9.                lowest_value_index = j
10.        # Самый маленький элемент меняем с первым в списке
11.        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]

12. # Проверяем, что оно работает
13.random_list_of_nums = [12, 8, 3, 20, 11]  
14.selection_sort(random_list_of_nums)  
15.print(random_list_of_nums) 

По мере увеличения значения i нужно проверять меньше элементов.

Время сортировки:

Затраты времени на сортировку выборкой в среднем составляют O(n²), где n — количество элементов списка.

Сортировка вставками:

Как и сортировка выборкой, этот алгоритм сегментирует список на две части: отсортированную и неотсортированную. Алгоритм перебирает второй сегмент и вставляет текущий элемент в правильную позицию первого сегмента.

Алгоритм:

Предполагается, что первый элемент списка отсортирован. Переходим к следующему элементу, обозначим его х. Если х больше первого, оставляем его на своём месте. Если он меньше, копируем его на вторую позицию, а х устанавливаем как первый элемент.

Переходя к другим элементам несортированного сегмента, перемещаем более крупные элементы в отсортированном сегменте вверх по списку, пока не встретим элемент меньше x или не дойдём до конца списка. В первом случае x помещается на правильную позицию.

Реализация:

1.def insertion_sort(nums):  
2.    # Сортировку начинаем со второго элемента, т.к. считается, что первый элемент уже отсортирован
3.    for i in range(1, len(nums)):
4.        item_to_insert = nums[i]
5.        # Сохраняем ссылку на индекс предыдущего элемента
6.        j = i - 1
7.        # Элементы отсортированного сегмента перемещаем вперёд, если они больше
8.        # элемента для вставки
9.        while j >= 0 and nums[j] > item_to_insert:
10.            nums[j + 1] = nums[j]
11.            j -= 1
12.        # Вставляем элемент
13.        nums[j + 1] = item_to_insert

14. # Проверяем, что оно работает
15.random_list_of_nums = [9, 1, 15, 28, 6]  
16.insertion_sort(random_list_of_nums)  
17.print(random_list_of_nums)

Время сортировки:

Время сортировки вставками в среднем равно O(n²), где n — количество элементов списка.

Пирамидальная сортировка:

Также известна как сортировка кучей. Этот популярный алгоритм, как и сортировки вставками или выборкой, сегментирует список на две части: отсортированную и неотсортированную. Алгоритм преобразует второй сегмент списка в структуру данных «куча» (heap), чтобы можно было эффективно определить самый большой элемент.

Алгоритм:

Сначала преобразуем список в Max Heap — бинарное дерево, где самый большой элемент является вершиной дерева. Затем помещаем этот элемент в конец списка. После перестраиваем Max Heap и снова помещаем новый наибольший элемент уже перед последним элементом в списке.

Этот процесс построения кучи повторяется, пока все вершины дерева не будут удалены.

Реализация:

Создадим вспомогательную функцию heapify() для реализации этого алгоритма:

1.def heapify(nums, heap_size, root_index):  
2.    # Индекс наибольшего элемента считаем корневым индексом
3.    largest = root_index
4.    left_child = (2 * root_index) + 1
5.    right_child = (2 * root_index) + 2

6.    # Если левый потомок корня — допустимый индекс, а элемент больше,
7.    # чем текущий наибольший, обновляем наибольший элемент
8.    if left_child < heap_size and nums[left_child] > nums[largest]:
9.        largest = left_child

10.    # То же самое для правого потомка корня
11.    if right_child < heap_size and nums[right_child] > nums[largest]:
12.        largest = right_child

13.    # Если наибольший элемент больше не корневой, они меняются местами
14.    if largest != root_index:
15.        nums[root_index], nums[largest] = nums[largest], nums[root_index]
16.        # Heapify the new root element to ensure it's the largest
17.        heapify(nums, heap_size, largest)

18.def heap_sort(nums):  
19.    n = len(nums)

20.    # Создаём Max Heap из списка
21.    # Второй аргумент означает остановку алгоритма перед элементом -1, т.е.
22.    # перед первым элементом списка
23.    # 3-й аргумент означает повторный проход по списку в обратном направлении, 
24.    # уменьшая счётчик i на 1 
25.    for i in range(n, -1, -1):
26.        heapify(nums, n, i)

27.    # Перемещаем корень Max Heap в конец списка
28.    for i in range(n - 1, 0, -1):
29.        nums[i], nums[0] = nums[0], nums[i]
30.        heapify(nums, i, 0)

31.# Проверяем, что оно работает
32.random_list_of_nums = [35, 12, 43, 8, 51]  
33.heap_sort(random_list_of_nums)  
34.print(random_list_of_nums)

Время сортировки:

В среднем время сортировки кучей составляет O(n log n), что уже значительно быстрее предыдущих алгоритмов.

Сортировка слиянием:

Этот алгоритм относится к алгоритмам «разделяй и властвуй». Он разбивает список на две части, каждую из них он разбивает ещё на две и т. д. Список разбивается пополам, пока не останутся единичные элементы.

Соседние элементы становятся отсортированными парами. Затем эти пары объединяются и сортируются с другими парами. Этот процесс продолжается до тех пор, пока не отсортируются все элементы.

Алгоритм:

Список рекурсивно разделяется пополам, пока в итоге не получатся списки размером в один элемент. Массив из одного элемента считается упорядоченным. Соседние элементы сравниваются и соединяются вместе. Это происходит до тех пор, пока не получится полный отсортированный список.

Сортировка осуществляется путём сравнения наименьших элементов каждого подмассива. Первые элементы каждого подмассива сравниваются первыми. Наименьший элемент перемещается в результирующий массив. Счётчики результирующего массива и подмассива, откуда был взят элемент, увеличиваются на 1.

Реализация:

1.def merge(left_list, right_list):  
2.    sorted_list = []
3.    left_list_index = right_list_index = 0
4.
5.    # Длина списков часто используется, поэтому создадим переменные для удобства
6.    left_list_length, right_list_length = len(left_list), len(right_list)

7.    for _ in range(left_list_length + right_list_length):
8.        if left_list_index < left_list_length and right_list_index < right_list_length:
9.            # Сравниваем первые элементы в начале каждого списка
10.            # Если первый элемент левого подсписка меньше, добавляем его
11.            # в отсортированный массив
12.            if left_list[left_list_index] <= right_list[right_list_index]:
13.                sorted_list.append(left_list[left_list_index])
14.                left_list_index += 1
15.            # Если первый элемент правого подсписка меньше, добавляем его
16.            # в отсортированный массив
17.            else:
18.                sorted_list.append(right_list[right_list_index])
19.                right_list_index += 1

20.        # Если достигнут конец левого списка, элементы правого списка
21.        # добавляем в конец результирующего списка
22.        elif left_list_index == left_list_length:
23.            sorted_list.append(right_list[right_list_index])
24.            right_list_index += 1
25.        # Если достигнут конец правого списка, элементы левого списка
26.        # добавляем в отсортированный массив
27.        elif right_list_index == right_list_length:
28.            sorted_list.append(left_list[left_list_index])
29.            left_list_index += 1

30.    return sorted_list

31.def merge_sort(nums):  
32.    # Возвращаем список, если он состоит из одного элемента
33.    if len(nums) <= 1:
34.        return nums

35.    # Для того чтобы найти середину списка, используем деление без остатка
36.    # Индексы должны быть integer
37.    mid = len(nums) // 2

38.    # Сортируем и объединяем подсписки
39.    left_list = merge_sort(nums[:mid])
40.    right_list = merge_sort(nums[mid:])

41.    # Объединяем отсортированные списки в результирующий
42.    return merge(left_list, right_list)

43.# Проверяем, что оно работает
44.random_list_of_nums = [120, 45, 68, 250, 176]  
45.random_list_of_nums = merge_sort(random_list_of_nums)  
46.print(random_list_of_nums)

Обратите внимание, что функция merge_sort(), в отличие от предыдущих алгоритмов, возвращает новый список, а не сортирует существующий. Поэтому такая сортировка требует больше памяти для создания нового списка того же размера, что и входной список.

Время сортировки:

В среднем время сортировки слиянием составляет O(n log n).

Быстрая сортировка:

Этот алгоритм также относится к алгоритмам «разделяй и властвуй». Его используют чаще других алгоритмов, описанных в этой статье. При правильной конфигурации он чрезвычайно эффективен и не требует дополнительной памяти, в отличие от сортировки слиянием. Массив разделяется на две части по разные стороны от опорного элемента. В процессе сортировки элементы меньше опорного помещаются перед ним, а равные или большие —позади.

Алгоритм:

Быстрая сортировка начинается с разбиения списка и выбора одного из элементов в качестве опорного. А всё остальное передвигаем так, чтобы этот элемент встал на своё место. Все элементы меньше него перемещаются влево, а равные и большие элементы перемещаются вправо.

Реализация:

Существует много вариаций данного метода. Способ разбиения массива, рассмотренный здесь, соответствует схеме Хоара (создателя данного алгоритма).

1.def partition(nums, low, high):  
2.    # Выбираем средний элемент в качестве опорного
3.    # Также возможен выбор первого, последнего
4.    # или произвольного элементов в качестве опорного
5.    pivot = nums[(low + high) // 2]
6.    i = low - 1
7.    j = high + 1
8.    while True:
9.        i += 1
10.        while nums[i] < pivot:
11.            i += 1

12.        j -= 1
13.        while nums[j] > pivot:
14.            j -= 1

15.        if i >= j:
16.            return j

17.        # Если элемент с индексом i (слева от опорного) больше, чем
18.        # элемент с индексом j (справа от опорного), меняем их местами
19.        nums[i], nums[j] = nums[j], nums[i]

20.def quick_sort(nums):  
21.    # Создадим вспомогательную функцию, которая вызывается рекурсивно
22.    def _quick_sort(items, low, high):
23.        if low < high:
24.            # This is the index after the pivot, where our lists are split
25.            split_index = partition(items, low, high)
26.            _quick_sort(items, low, split_index)
27.            _quick_sort(items, split_index + 1, high)

28.    _quick_sort(nums, 0, len(nums) - 1)

29.# Проверяем, что оно работает
30.random_list_of_nums = [22, 5, 1, 18, 99]  
31.quick_sort(random_list_of_nums)  
32.print(random_list_of_nums) 

Время выполнения:

В среднем время выполнения быстрой сортировки составляет O(n log n).

Обратите внимание, что алгоритм быстрой сортировки будет работать медленно, если опорный элемент равен наименьшему или наибольшему элементам списка. При таких условиях, в отличие от сортировок кучей и слиянием, обе из которых имеют в худшем случае время сортировки O(n log n), быстрая сортировка в худшем случае будет выполняться O(n²).

Встроенные функции сортировки на Python
Иногда полезно знать перечисленные выше алгоритмы, но в большинстве случаев разработчик, скорее всего, будет использовать функции сортировки, уже предоставленные в языке программирования.

Отсортировать содержимое списка можно с помощью стандартного метода sort():

1.>>> apples_eaten_a_day = [2, 1, 1, 3, 1, 2, 2]
2.>>> apples_eaten_a_day.sort()
3.>>> apples_eaten_a_day
4.[1, 1, 1, 2, 2, 2, 3]

Или можно использовать функцию sorted() для создания нового отсортированного списка, оставив входной список нетронутым:

1.>>> apples_eaten_a_day_2 = [2, 1, 1, 3, 1, 2, 2]
2.>>> sorted_apples = sorted(apples_eaten_a_day_2)
3.>>> sorted_apples
4.[1, 1, 1, 2, 2, 2, 3]

Оба эти метода сортируют в порядке возрастания, но можно изменить порядок, установив для флага reverse значение True:

# Обратная сортировка списка на месте

1.>>> apples_eaten_a_day.sort(reverse=True)
2.>>> apples_eaten_a_day
3.[3, 2, 2, 2, 1, 1, 1]

# Обратная сортировка, чтобы получить новый список

1.>>> sorted_apples_desc = sorted(apples_eaten_a_day_2, reverse=True)
2.>>> sorted_apples_desc
3.[3,2, 2, 2, 1, 1, 1]

В отличие от других алгоритмов, обе функции в Python могут сортировать также списки кортежей и классов. Функция sorted() может сортировать любую последовательность, которая включает списки, строки, кортежи, словари, наборы и пользовательские итераторы, которые вы можете создать.

Функции в Python реализуют алгоритм Tim Sort, основанный на сортировке слиянием и сортировке вставкой.

Сравнение скоростей сортировок:

Для сравнения сгенерируем массив из 5000 чисел от 0 до 1000. Затем определим время, необходимое для завершения каждого алгоритма. Повторим каждый метод 10 раз, чтобы можно было более точно установить, насколько каждый из них производителен.



Пузырьковая сортировка — самый медленный из всех алгоритмов. Возможно, он будет полезен как введение в тему алгоритмов сортировки, но не подходит для практического использования.
Быстрая сортировка хорошо оправдывает своё название, почти в два раза быстрее, чем сортировка слиянием, и не требуется дополнительное место для результирующего массива.
Сортировка вставками выполняет меньше сравнений, чем сортировка выборкой и в реальности должна быть производительнее, но в данном эксперименте она выполняется немного медленней. Сортировка вставками делает гораздо больше обменов элементами. Если эти обмены занимают намного больше времени, чем сравнение самих элементов, то такой результат вполне закономерен.

Вы познакомились с шестью различными алгоритмами сортировок и их реализациями на Python. Масштаб сравнения и количество перестановок, которые выполняет алгоритм вместе со средой выполнения кода, будут определяющими факторами в производительности. В реальных приложениях Python рекомендуется использовать встроенные функции сортировки, поскольку они реализованы именно для удобства разработчика.

